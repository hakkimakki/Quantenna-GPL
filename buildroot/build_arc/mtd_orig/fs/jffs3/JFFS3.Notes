$Id: JFFS3.Notes,v 1.2 2005/01/05 15:53:07 dedekind Exp $

Currently just unstructured notes about JFFS3. May be some day this will be
turned into JFFS3 design or something similar (by somebody).

Any additions, fixes, notes, etc are welcomed.

Terminology
~~~~~~~~~~~
1. Node - TODO
2. Fragment tree, fragtree - TODO
3. Garbage Collector, GC - TODO
4, Garbage Collector Thread, GCT - TODO
5. Inode cache - TODO
6. Erasable block, eraseblock, Virtual block, JFFS3 block - TODO
7. Flash block, Flash sector, Sector - TODO
8. node_ref - small object of type 'struct jffs3_node_ref'. Each node on JFFS3
has the correspondent node_ref. node_refs are in-core objects.
9. In-core objects - those objects which are always kept in-core in JFFS3
irrespective on whether any work is being done by JFFS3 or not.
10. Write buffer, wbuf - TODO
11. Page - TODO
12. NAND Page - TODO
13. Inode node - TODO
14. Direntry node - TODO
15. Summary node - TODO
16. Padding node - TODO
17. Valid node - TODO
18. Obsolete node - TODO
19. Pristine node - TODO
20. Normal node - TODO
21. Deletion direntry - TODO
22. Dirty space - TODO
23. Wasted space - TODO

Notes
~~~~~

1. The length of node represented by the node_ref is calculated as:
	Offset of the next node - Offset of our node.
Offset means the physical offset of node on the flash. When calculating
the length of the last node in the eraseblock, there is no next node in
the eraseblock. So in this case the length of the node is:
	Offset of the next eraseblock - Offset of our node.
This calculation is done by the ref_totlen function.

3. Nodes can not overlap the eraseblock boundaries. But they may overlap
NAND pages boundary.

4. Apart from most other file systems JFFS3 eats more RAM if more data is
stored on the JFFS3 file system. This is because of JFFS3 needs to keep
track of all its nodes in order to be able quickly build the "map" of
any inode (inode's nodes are randomly distributed over the flash and
worse, are periodically moved by the GC). So, the more nodes are stored
on the JFFS3 file system, the more memory it requires. This is the drawback
of JFFS3.

5. GC not just moves valid nodes from one block to another, it also 
merges normal nodes producing pristine nodes from several normal nodes.
Thus, GC may fetch nodes not only from the currently GC-ed eraseblock,
but from another eraseblocks too. I.e., generally, GC works in terms of
blocks (this is its primary work to remove dirt), but at the same time,
it works in terms of inodes (this is just optimisation to merge normal
nodes producing pristine ones).
P.S. We speak about inode nodes here.

6. JFFS3 keeps track of wasted space. Wasted space is the space which
can not be reclaimed by the GC. For example, small paddings. It is
needed to prevent the GC loops when it infinitely tries to GC some
block but fails because there is unreclaimable space there. When the
the wasted size becomes > then some threshold, it is converted to dirty
space.

